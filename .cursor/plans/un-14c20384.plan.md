<!-- 14c20384-7eab-4928-b208-13c7607814df 4d511fe5-34fd-4b62-8830-5973968f8558 -->
## Kế hoạch chuẩn hoá precision cho Aster

### Mục tiêu

- Bỏ logic heuristic hiện tại (dựa trên quantity < 0.1/10/1000) cho Aster.
- Sử dụng đúng metadata từ Aster (stepSize, tickSize, minQty, minNotional nếu có) để:
- Tính và làm tròn quantity (base) từ size_usd.
- Làm tròn price đúng tickSize khi cần.
- Đảm bảo MARKETS và LIMIT orders cho Aster hoạt động ổn định, không còn lỗi kiểu quantity=0 hoặc precision lệch.

### Bước 1: Rà soát metadata Aster và SDK hiện tại

- Xem lại `perpsdex/aster/core/market.py` và `AsterClient` để xem đã có endpoint lấy thông tin symbol/market chưa.
- Nếu chưa có, xác định endpoint thích hợp từ docs Aster (thường tương tự `/fapi/v1/exchangeInfo` của Binance) để lấy:
- `stepSize` (LOT_SIZE filter),
- `tickSize` (PRICE_FILTER),
- `minQty`, `minNotional` nếu có.
- Quyết định cấu trúc Python để lưu metadata: dict cache theo symbol (`BTCUSDT` → metadata).

### Bước 2: Thiết kế lớp/tiện ích quản lý metadata

- Tạo 1 lớp helper hoặc hàm module-level, ví dụ `AsterSymbolMetaCache` hoặc `get_symbol_metadata(symbol_api: str)`:
- Lần đầu gọi: fetch từ Aster (`exchangeInfo` hoặc tương đương), parse, cache trong bộ nhớ.
- Các lần sau: đọc từ cache để tránh spam API.
- Định nghĩa rõ kiểu dữ liệu metadata:
- `step_size`, `tick_size`, `min_qty`, `min_notional`.

### Bước 3: Chuẩn hoá logic tính quantity cho MARKET

- Với `place_market_order` hiện tại:
- Đang: tự quyết precision dựa trên `quantity` (heuristic).
- Sửa thành:
  - Lấy `symbol_api` (BTCUSDT) và metadata.
  - Tính quantity = size_usd / price.
  - Làm tròn xuống theo `step_size` (floor về bội số step_size), đảm bảo `>= min_qty`.
  - Kiểm tra size_usd thực (quantity * price) `>= min_notional` nếu có, nếu không → trả về lỗi thân thiện (insufficient notional).
- Đảm bảo không còn logic “nhóm theo quantity < 0.1/10/1000”.

### Bước 4: Chuẩn hoá logic quantity cho LIMIT

- Trong `place_limit_order`:
- Dùng cùng helper tính quantity như MARKET, chỉ khác là dùng `price` là limit_price (thay vì price thị trường).
- Làm tròn quantity theo `step_size`.
- Xử lý case floor ra 0: nếu `size_usd` quá nhỏ so với `price` và `step_size` → báo lỗi rõ: "Size quá nhỏ, min size = ..." thay vì ép lên 1 step.
- Tương tự, validate `min_notional` nếu sàn yêu cầu.

### Bước 5: Chuẩn hoá price theo tickSize (nếu cần)

- Xác định từ metadata `tickSize` cho symbol.
- Với LIMIT:
- Làm tròn `price` về bội số tickSize (có thể floor hoặc round gần nhất tùy chiến lược; mặc định floor để không vượt giới hạn).
- Nếu người dùng gửi price không align, có thể:
  - Tự động điều chỉnh và log lại,
  - Hoặc trả lỗi 400: "price must be multiple of tickSize ..." (quyết định trước).
- Với STOP/TP/SL (nếu cần), dùng cùng tickSize.

### Bước 6: Tích hợp vào API `/api/order`

- Đảm bảo `handle_aster_order` chỉ truyền `size_usd` + `price` + `symbol_api` vào `OrderExecutor`, còn toàn bộ việc làm tròn/validate nằm trong `OrderExecutor`.
- Đồng bộ cách convert `symbol` → `symbol_api` (BTC → BTCUSDT) như đã làm ở MARKET.

### Bước 7: Logging và thông báo lỗi thân thiện

- Cải thiện log ở `OrderExecutor`:
- Log quantity trước/sau làm tròn, giá trị stepSize/tickSize.
- Log lý do reject phía client (minQty/minNotional) trước khi gửi lên Aster.
- Chuẩn hoá lỗi trả về cho API `/api/order`:
- Nếu lỗi do notional/qty nhỏ: message rõ ràng cho user FE.
- Nếu lỗi từ Aster (code -2019, -4003, …): map sang thông báo dễ hiểu.

### Bước 8: Test thủ công

- Test trên môi trường thật (tài khoản nhỏ, như case 20 USDT):
- MARKET LONG/SHORT BTC với size_usd nhỏ/vừa.
- LIMIT LONG/SHORT BTC ở các price khác nhau, đảm bảo:
  - quantity > 0,
  - không còn "Invalid symbol" hoặc "Quantity less than zero" do bug code,
  - nếu thiếu margin thì đúng là do số dư thực tế.
- So sánh hành vi với Web UI của Aster (nếu có) để xem size tối thiểu và cách làm tròn có khớp.